{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"O projeto","text":"<p>O Lost Encryptor foi criado na tentativa de sanar problemas envolvendo criptografia e codifica\u00e7\u00e3o em pilhas, imagine que queiramos pegar um texto, retirar ele de UTF-8 e passar para inteiro, somar 2 em cada caracter transformado e encriptar usando SHA1.</p> <p>Seria uma complica\u00e7\u00e3o e tanto, e para isso foi criado o pacote LostEncryptor</p>"},{"location":"ascii/","title":"Codificando em Ascii","text":"<p>Aqui est\u00e3o as fun\u00e7\u00f5es da classe <code>AsciiEncrypt</code> que o <code>LostEncrypt</code> herda para codificar o <code>self.data</code> em ascii.</p>"},{"location":"ascii/#LostEncryptor.ascii.AsciiEncrypt","title":"<code>AsciiEncrypt</code>","text":"<p>Classe que cont\u00e9m as fun\u00e7\u00f5es de codifica\u00e7\u00e3o ascii.</p> Note <p>\u00c9 preferivel utilizar o argumento return_type no <code>ascii_plus</code> e <code>ascii_subtract</code> como <code>ascii</code>, j\u00e1 que existem alguns caract\u00e9res que n\u00e3o podem ser visiveis quando convertidos novamente em texto.</p> Source code in <code>LostEncryptor\\ascii\\__init__.py</code> <pre><code>class AsciiEncrypt():\n\n    \"\"\"Classe que cont\u00e9m as fun\u00e7\u00f5es de codifica\u00e7\u00e3o ascii.\n\n    Note:\n        \u00c9 preferivel utilizar o argumento return_type no `ascii_plus` e `ascii_subtract` como `ascii`,\n        j\u00e1 que existem alguns caract\u00e9res que n\u00e3o podem ser visiveis quando convertidos novamente em texto.\n\n    \"\"\"\n\n    def __init__(self, data, ascii_table_interval = [0,256]):\n        self.data = data\n        self.ascii_table_interval = ascii_table_interval\n\n    def ascii_plus(self, n: int = 0, increment_for: int = 0, return_type: str = 'str') -&gt; str | list:\n\n        \"\"\"Fun\u00e7\u00e3o que converte `self.data` para ascii e soma com `n`\n\n        Note:\n            O `ascii_plus` n\u00e3o aceita o dado para ser codificado como atributo direto, \u00e9 necess\u00e1rio instanciar um objeto `LostEncrypt` ou\n            `AsciiEncrypt` e setar o `self.data`, fora isso a fun\u00e7\u00e3o n\u00e3o entrega nada.\n\n        Args:\n            n (int): Numero de casas a serem saltadas.\n            increment_for (int): Numero usado para servir como incremento a cada vez que uma casa \u00e9 saltada. \n            return_type (str): O tipo de retorno da fun\u00e7\u00e3o.\n\n        Returns:\n            (str | list): Pode ser ou em `string` ou `list` dependendo do valor de `return_type`\n\n        Examples:\n            Quero transformar o texto `teste` contido em `self.data` em ascii e somar 2 cada caracter.\n\n            &gt;&gt;&gt; objeto = LostEncrypt('teste')\n            &gt;&gt;&gt; print(asciiPlus(n=2))\n            vguvg\n        \"\"\"\n\n\n\n        match return_type:\n            case \"str\":\n\n                response = \"\"\n                for letter in self.data:\n                    ascii_transform = ord(letter) + n\n                    max_interval = ascii_transform // self.ascii_table_interval[1]\n                    response += chr(ascii_transform - self.ascii_table_interval[1]*max_interval)\n                    n += increment_for\n\n            case \"ascii\":\n\n                response = []\n                for letter in self.data:\n                    ascii_transform = ord(letter) + n\n                    max_interval = ascii_transform // self.ascii_table_interval[1]\n                    response.append(ascii_transform - self.ascii_table_interval[1]*max_interval)\n                    n += increment_for\n\n        self.data = response\n        return response\n\n\n    def ascii_subtract(self, n: int = 0, increment_for: int = 0, return_type: str = 'str'):\n        \"\"\"Fun\u00e7\u00e3o que converte `self.data` para ascii e subtrai com `n`\n\n        Note:\n            O `ascii_subtract` n\u00e3o aceita o dado para ser codificado como atributo direto, \u00e9 necess\u00e1rio instanciar um objeto `LostEncrypt` ou\n            `AsciiEncrypt` e setar o `self.data`, fora isso a fun\u00e7\u00e3o n\u00e3o entrega nada.\n\n        Args:\n            n (int): Numero de casas a serem saltadas para tr\u00e1s.\n            increment_for (int): Numero usado para servir como incremento a cada vez que uma casa \u00e9 saltada para tr\u00e1s. \n            return_type (str): O tipo de retorno da fun\u00e7\u00e3o.\n\n        Returns:\n            (str | list): Pode ser ou em `string` ou `list` dependendo do valor de `return_type`\n\n        Examples:\n            Quero transformar o texto `teste` contido em `self.data` em ascii e subtrair 2 cada caracter.\n\n            &gt;&gt;&gt; objeto = LostEncrypt('teste')\n            &gt;&gt;&gt; print(ascii_subtract(n=2))\n            rcqrc\n        \"\"\"\n\n        match return_type:\n\n            #! DEVE SER CORRIGIDO\n\n            case \"str\":\n                response = \"\"\n                for letter in self.data:\n                    ascii_transform = ord(letter) - n # -100\n                    min_interval = ascii_transform // -(self.ascii_table_interval[1])\n                    if ascii_transform &lt; 0:\n                        ascii_transform += 256\n                        if min_interval &gt; 1:\n                            ascii_transform += 256*min_interval-1\n                        response += chr(ascii_transform) # * Deve ser testado\n                    else:\n                        response += chr(ascii_transform)\n                    n += increment_for\n\n            case \"ascii\":\n                response = []\n                for letter in self.data:\n                    ascii_transform = ord(letter) - n\n                    min_interval = ascii_transform // -(self.ascii_table_interval[1])\n                    if ascii_transform &lt; 0:\n                        ascii_transform += 256\n                        if min_interval &gt; 1:\n                            ascii_transform += 256*min_interval-1\n                        response.append(ascii_transform) # * Deve ser testado\n                    else: \n                        response.append(ascii_transform)\n                    n += increment_for\n\n\n        self.data = response\n        return response\n</code></pre>"},{"location":"ascii/#LostEncryptor.ascii.AsciiEncrypt.ascii_plus","title":"<code>ascii_plus(n=0, increment_for=0, return_type='str')</code>","text":"<p>Fun\u00e7\u00e3o que converte <code>self.data</code> para ascii e soma com <code>n</code></p> Note <p>O <code>ascii_plus</code> n\u00e3o aceita o dado para ser codificado como atributo direto, \u00e9 necess\u00e1rio instanciar um objeto <code>LostEncrypt</code> ou <code>AsciiEncrypt</code> e setar o <code>self.data</code>, fora isso a fun\u00e7\u00e3o n\u00e3o entrega nada.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Numero de casas a serem saltadas.</p> <code>0</code> <code>increment_for</code> <code>int</code> <p>Numero usado para servir como incremento a cada vez que uma casa \u00e9 saltada. </p> <code>0</code> <code>return_type</code> <code>str</code> <p>O tipo de retorno da fun\u00e7\u00e3o.</p> <code>'str'</code> <p>Returns:</p> Type Description <code>str | list</code> <p>Pode ser ou em <code>string</code> ou <code>list</code> dependendo do valor de <code>return_type</code></p> <p>Examples:</p> <p>Quero transformar o texto <code>teste</code> contido em <code>self.data</code> em ascii e somar 2 cada caracter.</p> <pre><code>&gt;&gt;&gt; objeto = LostEncrypt('teste')\n&gt;&gt;&gt; print(asciiPlus(n=2))\nvguvg\n</code></pre> Source code in <code>LostEncryptor\\ascii\\__init__.py</code> <pre><code>def ascii_plus(self, n: int = 0, increment_for: int = 0, return_type: str = 'str') -&gt; str | list:\n\n    \"\"\"Fun\u00e7\u00e3o que converte `self.data` para ascii e soma com `n`\n\n    Note:\n        O `ascii_plus` n\u00e3o aceita o dado para ser codificado como atributo direto, \u00e9 necess\u00e1rio instanciar um objeto `LostEncrypt` ou\n        `AsciiEncrypt` e setar o `self.data`, fora isso a fun\u00e7\u00e3o n\u00e3o entrega nada.\n\n    Args:\n        n (int): Numero de casas a serem saltadas.\n        increment_for (int): Numero usado para servir como incremento a cada vez que uma casa \u00e9 saltada. \n        return_type (str): O tipo de retorno da fun\u00e7\u00e3o.\n\n    Returns:\n        (str | list): Pode ser ou em `string` ou `list` dependendo do valor de `return_type`\n\n    Examples:\n        Quero transformar o texto `teste` contido em `self.data` em ascii e somar 2 cada caracter.\n\n        &gt;&gt;&gt; objeto = LostEncrypt('teste')\n        &gt;&gt;&gt; print(asciiPlus(n=2))\n        vguvg\n    \"\"\"\n\n\n\n    match return_type:\n        case \"str\":\n\n            response = \"\"\n            for letter in self.data:\n                ascii_transform = ord(letter) + n\n                max_interval = ascii_transform // self.ascii_table_interval[1]\n                response += chr(ascii_transform - self.ascii_table_interval[1]*max_interval)\n                n += increment_for\n\n        case \"ascii\":\n\n            response = []\n            for letter in self.data:\n                ascii_transform = ord(letter) + n\n                max_interval = ascii_transform // self.ascii_table_interval[1]\n                response.append(ascii_transform - self.ascii_table_interval[1]*max_interval)\n                n += increment_for\n\n    self.data = response\n    return response\n</code></pre>"},{"location":"ascii/#LostEncryptor.ascii.AsciiEncrypt.ascii_subtract","title":"<code>ascii_subtract(n=0, increment_for=0, return_type='str')</code>","text":"<p>Fun\u00e7\u00e3o que converte <code>self.data</code> para ascii e subtrai com <code>n</code></p> Note <p>O <code>ascii_subtract</code> n\u00e3o aceita o dado para ser codificado como atributo direto, \u00e9 necess\u00e1rio instanciar um objeto <code>LostEncrypt</code> ou <code>AsciiEncrypt</code> e setar o <code>self.data</code>, fora isso a fun\u00e7\u00e3o n\u00e3o entrega nada.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Numero de casas a serem saltadas para tr\u00e1s.</p> <code>0</code> <code>increment_for</code> <code>int</code> <p>Numero usado para servir como incremento a cada vez que uma casa \u00e9 saltada para tr\u00e1s. </p> <code>0</code> <code>return_type</code> <code>str</code> <p>O tipo de retorno da fun\u00e7\u00e3o.</p> <code>'str'</code> <p>Returns:</p> Type Description <code>str | list</code> <p>Pode ser ou em <code>string</code> ou <code>list</code> dependendo do valor de <code>return_type</code></p> <p>Examples:</p> <p>Quero transformar o texto <code>teste</code> contido em <code>self.data</code> em ascii e subtrair 2 cada caracter.</p> <pre><code>&gt;&gt;&gt; objeto = LostEncrypt('teste')\n&gt;&gt;&gt; print(ascii_subtract(n=2))\nrcqrc\n</code></pre> Source code in <code>LostEncryptor\\ascii\\__init__.py</code> <pre><code>def ascii_subtract(self, n: int = 0, increment_for: int = 0, return_type: str = 'str'):\n    \"\"\"Fun\u00e7\u00e3o que converte `self.data` para ascii e subtrai com `n`\n\n    Note:\n        O `ascii_subtract` n\u00e3o aceita o dado para ser codificado como atributo direto, \u00e9 necess\u00e1rio instanciar um objeto `LostEncrypt` ou\n        `AsciiEncrypt` e setar o `self.data`, fora isso a fun\u00e7\u00e3o n\u00e3o entrega nada.\n\n    Args:\n        n (int): Numero de casas a serem saltadas para tr\u00e1s.\n        increment_for (int): Numero usado para servir como incremento a cada vez que uma casa \u00e9 saltada para tr\u00e1s. \n        return_type (str): O tipo de retorno da fun\u00e7\u00e3o.\n\n    Returns:\n        (str | list): Pode ser ou em `string` ou `list` dependendo do valor de `return_type`\n\n    Examples:\n        Quero transformar o texto `teste` contido em `self.data` em ascii e subtrair 2 cada caracter.\n\n        &gt;&gt;&gt; objeto = LostEncrypt('teste')\n        &gt;&gt;&gt; print(ascii_subtract(n=2))\n        rcqrc\n    \"\"\"\n\n    match return_type:\n\n        #! DEVE SER CORRIGIDO\n\n        case \"str\":\n            response = \"\"\n            for letter in self.data:\n                ascii_transform = ord(letter) - n # -100\n                min_interval = ascii_transform // -(self.ascii_table_interval[1])\n                if ascii_transform &lt; 0:\n                    ascii_transform += 256\n                    if min_interval &gt; 1:\n                        ascii_transform += 256*min_interval-1\n                    response += chr(ascii_transform) # * Deve ser testado\n                else:\n                    response += chr(ascii_transform)\n                n += increment_for\n\n        case \"ascii\":\n            response = []\n            for letter in self.data:\n                ascii_transform = ord(letter) - n\n                min_interval = ascii_transform // -(self.ascii_table_interval[1])\n                if ascii_transform &lt; 0:\n                    ascii_transform += 256\n                    if min_interval &gt; 1:\n                        ascii_transform += 256*min_interval-1\n                    response.append(ascii_transform) # * Deve ser testado\n                else: \n                    response.append(ascii_transform)\n                n += increment_for\n\n\n    self.data = response\n    return response\n</code></pre>"},{"location":"codes/","title":"Codificando em Bases","text":"<p>Aqui est\u00e3o as fun\u00e7\u00f5es herdadas do <code>LostEncrypt</code> que encoda e decoda em bases.</p>"},{"location":"codes/#LostEncryptor.algorithm.codes.Codes","title":"<code>Codes</code>","text":"<p>Classe que cont\u00e9m fun\u00e7\u00f5es para codificar e decodificar em bases.</p> Source code in <code>LostEncryptor\\algorithm\\codes.py</code> <pre><code>class Codes():\n    \"\"\"Classe que cont\u00e9m fun\u00e7\u00f5es para codificar e decodificar em bases.\n\n    \"\"\"\n\n    def __init__(self,data):\n        self.data = data\n\n    def EncodeBase64(self):\n        \"\"\"Fun\u00e7\u00e3o que encoda o `self.data` em `base64`\n\n        Returns:\n            (bytes): Retorna em bytes o `self.data` em `base64`\n        \"\"\"\n        self.data = base64.b64encode(self.data)\n        return self.data\n\n    def DecodeBase64(self):\n        \"\"\"Fun\u00e7\u00e3o que decoda o `self.data` em `base64`\n\n        Returns:\n            (bytes): Retorna em bytes o `self.data` decodado em `base64`\n        \"\"\"\n\n        self.data = base64.b64decode(self.data)\n        return self.data \n</code></pre>"},{"location":"codes/#LostEncryptor.algorithm.codes.Codes.DecodeBase64","title":"<code>DecodeBase64()</code>","text":"<p>Fun\u00e7\u00e3o que decoda o <code>self.data</code> em <code>base64</code></p> <p>Returns:</p> Type Description <code>bytes</code> <p>Retorna em bytes o <code>self.data</code> decodado em <code>base64</code></p> Source code in <code>LostEncryptor\\algorithm\\codes.py</code> <pre><code>def DecodeBase64(self):\n    \"\"\"Fun\u00e7\u00e3o que decoda o `self.data` em `base64`\n\n    Returns:\n        (bytes): Retorna em bytes o `self.data` decodado em `base64`\n    \"\"\"\n\n    self.data = base64.b64decode(self.data)\n    return self.data \n</code></pre>"},{"location":"codes/#LostEncryptor.algorithm.codes.Codes.EncodeBase64","title":"<code>EncodeBase64()</code>","text":"<p>Fun\u00e7\u00e3o que encoda o <code>self.data</code> em <code>base64</code></p> <p>Returns:</p> Type Description <code>bytes</code> <p>Retorna em bytes o <code>self.data</code> em <code>base64</code></p> Source code in <code>LostEncryptor\\algorithm\\codes.py</code> <pre><code>def EncodeBase64(self):\n    \"\"\"Fun\u00e7\u00e3o que encoda o `self.data` em `base64`\n\n    Returns:\n        (bytes): Retorna em bytes o `self.data` em `base64`\n    \"\"\"\n    self.data = base64.b64encode(self.data)\n    return self.data\n</code></pre>"},{"location":"criptografando/","title":"Criptografando em hashs","text":"<p>Aqui est\u00e3o algumas das fun\u00e7\u00f5es e propriedades da classe <code>ToHASHs</code> que o <code>LostEncrypt</code> herda.</p>"},{"location":"criptografando/#LostEncryptor.algorithm.tohashs.ToHASHs","title":"<code>ToHASHs</code>","text":"<p>Classe que cont\u00e9m as fun\u00e7\u00f5es de hash para a classe <code>LostEncrypt</code></p> Source code in <code>LostEncryptor\\algorithm\\tohashs.py</code> <pre><code>class ToHASHs():\n    \"\"\"Classe que cont\u00e9m as fun\u00e7\u00f5es de hash para a classe `LostEncrypt`\n\n    \"\"\"\n\n\n    def __init__(self,data:str = '') -&gt; None:\n        self.data = data\n\n    def is_list_or_str(self,data): #* Isto \u00e9 utilit\u00e1rio\n\n        data_encode = None\n        if isinstance(data,str):\n            data_encode = data.encode()\n        elif isinstance(data,list):\n            data_encode = bytes(data)\n\n        return data_encode\n\n    def return_type_is(self,return_type,cripto): #* Isto \u00e9 utilit\u00e1rio\n\n        data = None\n        if return_type == 'hexadecimal':\n            data = cripto.hexdigest()\n        elif return_type == 'bytes':\n            data = cripto.digest()\n\n        return data\n\n\n    def to_md5(self, return_type: Literal['hexadecimal','decimal'] = 'hexadecimal') -&gt; str | bytes:\n        \"\"\"Criptografa o `self.data` em `MD5`\n\n        Args:\n            return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n        Returns:\n            (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n\n        \"\"\"\n\n\n        data_encode = self.is_list_or_str(self.data)\n        criptografado = hashlib.md5(data_encode)   \n        self.data = self.return_type_is(return_type,criptografado)\n        return self.data\n\n    def to_sha1(self, return_type: str = 'hexadecimal') -&gt; str | bytes:\n        \"\"\"Criptografa o `self.data` em `SHA1`\n\n        Args:\n            return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n        Returns:\n            (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n        \"\"\"\n\n        data_encode = self.is_list_or_str(self.data)\n        criptografado = hashlib.sha1(data_encode)   \n        self.data = self.return_type_is(return_type,criptografado)\n        return self.data\n\n    def to_sha256(self, return_type: str = 'hexadecimal') -&gt; str | bytes:\n        \"\"\"Criptografa o `self.data` em `SHA256`\n\n        Args:\n            return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n        Returns:\n            (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n        \"\"\"\n\n        data_encode = self.is_list_or_str(self.data)\n        criptografado = hashlib.sha256(data_encode)   \n        self.data = self.return_type_is(return_type,criptografado)\n        return self.data\n\n    def to_sha512(self, return_type: str = 'hexadecimal') -&gt; str | bytes:\n        \"\"\"Criptografa o `self.data` em `SHA512`\n\n        Args:\n            return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n        Returns:\n            (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n        \"\"\"\n\n        data_encode = self.is_list_or_str(self.data)\n        criptografado = hashlib.sha512(data_encode)   \n        self.data = self.return_type_is(return_type,criptografado)\n        return self.data\n</code></pre>"},{"location":"criptografando/#LostEncryptor.algorithm.tohashs.ToHASHs.to_md5","title":"<code>to_md5(return_type='hexadecimal')</code>","text":"<p>Criptografa o <code>self.data</code> em <code>MD5</code></p> <p>Parameters:</p> Name Type Description Default <code>return_type</code> <code>Literal['bytes', 'hexadecimal']</code> <p>Especifica o tipo de dados de retorno.</p> <code>'hexadecimal'</code> <p>Returns:</p> Type Description <code>Literal['hexadecimal', 'bytes']</code> <p>Em bytes ou em hexadecimal.</p> Source code in <code>LostEncryptor\\algorithm\\tohashs.py</code> <pre><code>def to_md5(self, return_type: Literal['hexadecimal','decimal'] = 'hexadecimal') -&gt; str | bytes:\n    \"\"\"Criptografa o `self.data` em `MD5`\n\n    Args:\n        return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n    Returns:\n        (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n\n    \"\"\"\n\n\n    data_encode = self.is_list_or_str(self.data)\n    criptografado = hashlib.md5(data_encode)   \n    self.data = self.return_type_is(return_type,criptografado)\n    return self.data\n</code></pre>"},{"location":"criptografando/#LostEncryptor.algorithm.tohashs.ToHASHs.to_sha1","title":"<code>to_sha1(return_type='hexadecimal')</code>","text":"<p>Criptografa o <code>self.data</code> em <code>SHA1</code></p> <p>Parameters:</p> Name Type Description Default <code>return_type</code> <code>Literal['bytes', 'hexadecimal']</code> <p>Especifica o tipo de dados de retorno.</p> <code>'hexadecimal'</code> <p>Returns:</p> Type Description <code>Literal['hexadecimal', 'bytes']</code> <p>Em bytes ou em hexadecimal.</p> Source code in <code>LostEncryptor\\algorithm\\tohashs.py</code> <pre><code>def to_sha1(self, return_type: str = 'hexadecimal') -&gt; str | bytes:\n    \"\"\"Criptografa o `self.data` em `SHA1`\n\n    Args:\n        return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n    Returns:\n        (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n    \"\"\"\n\n    data_encode = self.is_list_or_str(self.data)\n    criptografado = hashlib.sha1(data_encode)   \n    self.data = self.return_type_is(return_type,criptografado)\n    return self.data\n</code></pre>"},{"location":"criptografando/#LostEncryptor.algorithm.tohashs.ToHASHs.to_sha256","title":"<code>to_sha256(return_type='hexadecimal')</code>","text":"<p>Criptografa o <code>self.data</code> em <code>SHA256</code></p> <p>Parameters:</p> Name Type Description Default <code>return_type</code> <code>Literal['bytes', 'hexadecimal']</code> <p>Especifica o tipo de dados de retorno.</p> <code>'hexadecimal'</code> <p>Returns:</p> Type Description <code>Literal['hexadecimal', 'bytes']</code> <p>Em bytes ou em hexadecimal.</p> Source code in <code>LostEncryptor\\algorithm\\tohashs.py</code> <pre><code>def to_sha256(self, return_type: str = 'hexadecimal') -&gt; str | bytes:\n    \"\"\"Criptografa o `self.data` em `SHA256`\n\n    Args:\n        return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n    Returns:\n        (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n    \"\"\"\n\n    data_encode = self.is_list_or_str(self.data)\n    criptografado = hashlib.sha256(data_encode)   \n    self.data = self.return_type_is(return_type,criptografado)\n    return self.data\n</code></pre>"},{"location":"criptografando/#LostEncryptor.algorithm.tohashs.ToHASHs.to_sha512","title":"<code>to_sha512(return_type='hexadecimal')</code>","text":"<p>Criptografa o <code>self.data</code> em <code>SHA512</code></p> <p>Parameters:</p> Name Type Description Default <code>return_type</code> <code>Literal['bytes', 'hexadecimal']</code> <p>Especifica o tipo de dados de retorno.</p> <code>'hexadecimal'</code> <p>Returns:</p> Type Description <code>Literal['hexadecimal', 'bytes']</code> <p>Em bytes ou em hexadecimal.</p> Source code in <code>LostEncryptor\\algorithm\\tohashs.py</code> <pre><code>def to_sha512(self, return_type: str = 'hexadecimal') -&gt; str | bytes:\n    \"\"\"Criptografa o `self.data` em `SHA512`\n\n    Args:\n        return_type (Literal['bytes','hexadecimal']): Especifica o tipo de dados de retorno.\n\n    Returns:\n        (Literal['hexadecimal','bytes']): Em bytes ou em hexadecimal.\n    \"\"\"\n\n    data_encode = self.is_list_or_str(self.data)\n    criptografado = hashlib.sha512(data_encode)   \n    self.data = self.return_type_is(return_type,criptografado)\n    return self.data\n</code></pre>"},{"location":"guia/","title":"Classe base","text":"<p><code>LostEncrypt</code> \u00e9 a classe base para a aplica\u00e7\u00e3o, \u00e9 nela que haver\u00e1 todos as fun\u00e7\u00f5es de criptografia e codifica\u00e7\u00e3o, por\u00e9m essa mesmas classe utiliza outras classes, no caso s\u00e3o eles: <code>Codes</code>, <code>AsciiEncrypt</code>,<code>ToHASHs</code></p>"},{"location":"guia/#LostEncryptor.LostEncrypt","title":"<code>LostEncrypt</code>","text":"<p>             Bases: <code>AsciiEncrypt</code>, <code>ToHASHs</code>, <code>Codes</code></p> <p>LostEncrypt herda propriedades e func\u00f5es de todas as outras classes.</p> Source code in <code>LostEncryptor\\__init__.py</code> <pre><code>class LostEncrypt(AsciiEncrypt,ToHASHs,Codes):\n    \"\"\"LostEncrypt herda propriedades e func\u00f5es de todas as outras classes.\n    \"\"\"\n\n    def __init__(self, data: str) -&gt; None:\n\n        \"\"\"Fun\u00e7\u00e3o inicializadora da classe LostEncrypt\n\n        Args:\n            data (str): dados que v\u00e3o ser criptografados\n        \"\"\"\n\n        AsciiEncrypt.__init__(self,data)\n        Codes.__init__(self,data)\n        ToHASHs.__init__(self,data)\n        self.data = str(data)\n        self.encodingTypes = ['ascii','utf8']\n\n    def toBytes(self,encoding: Literal[\"ascii\", \"utf8\"]):\n\n        \"\"\"Fun\u00e7\u00e3o que transforma o `self.data` para bytes.\n\n        Args:\n            encoding (Literal[\"ascii\", \"utf8\"]): Tipos de codifica\u00e7\u00e3o aceitas\n\n        Raises:\n            ValueError: [description]\n\n        Returns:\n            (bytes): O `self.data` codificado para bytes\n\n        \"\"\"\n\n        if encoding in self.encodingTypes:\n            self.data = self.data.encode(encoding=encoding)\n            return self.data\n        raise ValueError(f\"{encoding} not is one type of possible\")\n</code></pre>"},{"location":"guia/#LostEncryptor.LostEncrypt.__init__","title":"<code>__init__(data)</code>","text":"<p>Fun\u00e7\u00e3o inicializadora da classe LostEncrypt</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>dados que v\u00e3o ser criptografados</p> required Source code in <code>LostEncryptor\\__init__.py</code> <pre><code>def __init__(self, data: str) -&gt; None:\n\n    \"\"\"Fun\u00e7\u00e3o inicializadora da classe LostEncrypt\n\n    Args:\n        data (str): dados que v\u00e3o ser criptografados\n    \"\"\"\n\n    AsciiEncrypt.__init__(self,data)\n    Codes.__init__(self,data)\n    ToHASHs.__init__(self,data)\n    self.data = str(data)\n    self.encodingTypes = ['ascii','utf8']\n</code></pre>"},{"location":"guia/#LostEncryptor.LostEncrypt.toBytes","title":"<code>toBytes(encoding)</code>","text":"<p>Fun\u00e7\u00e3o que transforma o <code>self.data</code> para bytes.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>Literal['ascii', 'utf8']</code> <p>Tipos de codifica\u00e7\u00e3o aceitas</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>[description]</p> <p>Returns:</p> Type Description <code>bytes</code> <p>O <code>self.data</code> codificado para bytes</p> Source code in <code>LostEncryptor\\__init__.py</code> <pre><code>def toBytes(self,encoding: Literal[\"ascii\", \"utf8\"]):\n\n    \"\"\"Fun\u00e7\u00e3o que transforma o `self.data` para bytes.\n\n    Args:\n        encoding (Literal[\"ascii\", \"utf8\"]): Tipos de codifica\u00e7\u00e3o aceitas\n\n    Raises:\n        ValueError: [description]\n\n    Returns:\n        (bytes): O `self.data` codificado para bytes\n\n    \"\"\"\n\n    if encoding in self.encodingTypes:\n        self.data = self.data.encode(encoding=encoding)\n        return self.data\n    raise ValueError(f\"{encoding} not is one type of possible\")\n</code></pre>"}]}